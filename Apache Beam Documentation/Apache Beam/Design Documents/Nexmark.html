<p>Nexmark is a suite of queries (pipelines) used to measure performance and non-regression in Beam (see <a class="external-link" href="https://beam.apache.org/documentation/sdks/java/nexmark/" rel="nofollow">https://beam.apache.org/documentation/sdks/java/nexmark/</a>).</p><p style="margin-left: 30.0px;">Links to the original Nexmark papers:</p><ul><li style="list-style-type: none;background-image: none;"><ul><li><a class="external-link" href="http://datalab.cs.pdx.edu/niagara/pstream/nexmark.pdf" rel="nofollow">http://datalab.cs.pdx.edu/niagara/pstream/nexmark.pdf</a></li><li><a class="external-link" href="http://datalab.cs.pdx.edu/niagara/NEXMark/" rel="nofollow">http://datalab.cs.pdx.edu/niagara/NEXMark/</a></li></ul></li></ul><p>Some queries can be very complex. To ease their maintenance, here is a presentation of the architecture along with pseudo-code of the queries:</p><p><br/></p><p><strong style="font-size: 20.0px;letter-spacing: 0.0px;"><span style="color: rgb(102,102,102);">Components of NexMark</span></strong></p><p><strong><span style="color: rgb(102,102,102);"><span class="confluence-embedded-file-wrapper"><img class="confluence-embedded-image" draggable="false" src="/confluence/download/attachments/89068348/nexmark%20components%20small.png?version=1&amp;modificationDate=1534793047000&amp;api=v2" data-image-src="/confluence/download/attachments/89068348/nexmark%20components%20small.png?version=1&amp;modificationDate=1534793047000&amp;api=v2" data-unresolved-comment-count="0" data-linked-resource-id="89068942" data-linked-resource-version="1" data-linked-resource-type="attachment" data-linked-resource-default-alias="nexmark components small.png" data-base-url="https://cwiki.apache.org/confluence" data-linked-resource-content-type="image/png" data-linked-resource-container-id="89068348" data-linked-resource-container-version="11" alt=""></span><br/></span></strong></p><ul><li style="list-style-type: disc;"><p><span><strong>Generator</strong>:</span></p></li><ul><li style="list-style-type: circle;"><p><span>generation of timestamped events (bids, persons, auctions) correlated between each other</span></p></li></ul><li style="list-style-type: disc;"><p><span><strong>NexmarkLauncher</strong>: </span></p></li><ul><li style="list-style-type: none;background-image: none;"><p><span>creates sources that use the generator</span></p></li><li style="list-style-type: circle;"><p><span>queries pipelines launching, monitoring</span></p></li></ul><li style="list-style-type: disc;"><p><span><strong>Output metrics</strong>:</span></p></li><ul><li style="list-style-type: circle;"><p><span>Each query includes ParDos to update metrics</span></p></li><li style="list-style-type: circle;"><p><span>execution time, processing event rate, number of results,                      but also invalid auctions/bids, …</span></p></li></ul><li style="list-style-type: none;background-image: none;"><p><span><strong>Modes</strong>:</span></p></li><ul><li style="list-style-type: circle;"><p><span>Batch mode: test data is finite and uses a BoundedSource</span></p></li><li style="list-style-type: circle;"><p><span>Streaming mode: test data is finite but uses an UnboundedSource to trigger streaming mode in runners</span></p></li></ul></ul><p><span><span><br/></span></span></p><h2 id="Nexmark-Queriespseudocode"><strong><span style="color: rgb(102,102,102);">Queries pseudo code</span></strong></h2><p><strong><span style="color: rgb(102,102,102);"><br/></span></strong></p><p><strong><span style="color: rgb(0,0,0);">Query 0 (not part of original NexMark): Pass-through. </span></strong></p><ul><li style="list-style-type: disc;"><p><span>Allows us to measure the monitoring overhead.</span></p></li><ul><li style="list-style-type: circle;"><p><span>serializes and deserializes using coder</span></p></li><li style="list-style-type: circle;"><p><span>Uses Aggregator for byte size counter</span></p></li></ul></ul><hr/><p><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 1: What are the bid values in Euro's? (Currency Conversion)</span></strong></p><ul><li style="list-style-type: none;background-image: none;"><p><span>Simple map</span></p></li><ul><li style="list-style-type: circle;"><p><span>Filter + ParDo to extract bids out of events</span></p></li><li style="list-style-type: circle;"><p><span>ParDo that outputs Bid objects with price converted</span></p><p><span><br/></span></p></li></ul></ul><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-1616884870"><div id="expander-control-1616884870" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-1616884870" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Istream(auction, DOLTOEUR(price), bidder, datetime)</span></pre><pre><span style="color: rgb(0,128,0);">FROM bid [ROWS UNBOUNDED];</span></pre></div></div><hr/><p><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 2: Find bids with specific auction ids and show their bid price.</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates simple filter</span></p></li><ul><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Filter</span><span> + </span><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>extract</span><span> </span><span style="color: rgb(109,158,235);">bids</span><span> out of events</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Filter</span><span> to </span><span>keep</span><span> </span><span style="color: rgb(109,158,235);">bids</span><span> with correct </span><span style="color: rgb(109,158,235);">auctionId</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> that </span><span>outputs</span><span> AuctionPrice(auction, price) objects</span></p><p><span><br/></span></p></li></ul></ul><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-1030923040"><div id="expander-control-1030923040" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-1030923040" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Rstream(auction, price)</span></pre><pre><span style="color: rgb(0,128,0);">FROM Bid [NOW]</span></pre><pre><span style="color: rgb(0,128,0);">WHERE</span></pre><pre><span style="color: rgb(0,128,0);"> auction = 1007</span></pre><pre><span style="color: rgb(0,128,0);"> OR auction = 1020</span></pre><pre><span style="color: rgb(0,128,0);"> OR auction = 2001</span></pre><pre><span style="color: rgb(0,128,0);"> OR auction = 2019</span></pre><pre><span style="color: rgb(0,128,0);"> OR auction = 2087;</span></pre></div></div><p><br/></p><hr/><p><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 3: Who is selling in particular US states?</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates incremental join of the auctions and the persons collections </span></p></li><li style="list-style-type: disc;"><p><span>uses global window and using per-key state and timer APIs</span></p></li><ul><li style="list-style-type: circle;"><p><span>Apply </span><span style="color: rgb(147,196,125);">global window</span><span> to events with </span><span style="color: rgb(147,196,125);">trigger</span><span> </span><span style="color: rgb(147,196,125);">repeatedly after at least nbEvents in pane</span><span> =&gt;  results will be materialized each time nbEvents are received.</span></p></li><li style="list-style-type: circle;"><p><span>input1</span><span>: collection of </span><span style="color: rgb(109,158,235);">auctions</span><span> events </span><span>filtered</span><span> by </span><span style="color: rgb(109,158,235);">category</span><span> and </span><span>keyed</span><span> by </span><span style="color: rgb(109,158,235);">seller id</span></p></li><li style="list-style-type: circle;"><p><span>input2</span><span>: collection of </span><span style="color: rgb(109,158,235);">persons</span><span> events </span><span>filtered</span><span> by </span><span style="color: rgb(109,158,235);">US state codes</span><span> and </span><span>keyed</span><span> by </span><span style="color: rgb(109,158,235);">person id</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">CoGroupByKey</span><span> to </span><span>group</span><span> </span><span style="color: rgb(109,158,235);">auctions</span><span> and </span><span style="color: rgb(109,158,235);">persons</span><span> by </span><span style="color: rgb(109,158,235);">personId</span><span>/</span><span style="color: rgb(109,158,235);">sellerId</span><span> + </span><span style="color: rgb(147,196,125);">tags</span><span> to distinguish </span><span style="color: rgb(109,158,235);">persons</span><span> and </span><span style="color: rgb(109,158,235);">auctions</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to do the </span><span>incremental</span><span> </span><span>join</span><span>: </span><span style="color: rgb(109,158,235);">auctions</span><span> and </span><span style="color: rgb(109,158,235);">person</span><span> events can arrive out of order</span></p></li><ul><li style="list-style-type: square;"><p><span style="color: rgb(109,158,235);">person</span><span> element </span><span>stored</span><span> in persistent state in order to match future </span><span style="color: rgb(109,158,235);">auctions</span><span> by that </span><span style="color: rgb(109,158,235);">person</span><span>. Set a </span><span style="color: rgb(147,196,125);">timer</span><span> to </span><span>clear</span><span> the person </span><span style="color: rgb(147,196,125);">state</span><span> after a TTL</span></p></li><li style="list-style-type: square;"><p><span style="color: rgb(109,158,235);">auction</span><span> elements </span><span>stored</span><span> in persistent </span><span style="color: rgb(147,196,125);">state</span><span> until we have seen the corresponding </span><span style="color: rgb(109,158,235);">person</span><span> record. Then, it can be </span><span>output</span><span> and </span><span>cleared</span></p></li></ul><li style="list-style-type: circle;"><p><span>output</span><span> NameCityStateId(<a class="external-link" href="http://person.name" rel="nofollow">person.name</a>, person.city, person.state, <a class="external-link" href="http://auction.id" rel="nofollow">auction.id</a>) objects</span></p></li></ul></ul><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-656982660"><div id="expander-control-656982660" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-656982660" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Istream(<a class="external-link" href="http://P.name" rel="nofollow"><span style="color: rgb(0,128,0);">P.name</span></a>, P.city, P.state, <a class="external-link" href="http://A.id" rel="nofollow"><span style="color: rgb(0,128,0);">A.id</span></a>)</span></pre><pre><span style="color: rgb(0,128,0);">FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]</span></pre><pre><span style="color: rgb(0,128,0);">WHERE</span></pre><pre><span style="color: rgb(0,128,0);"> A.seller = <a class="external-link" href="http://P.id" rel="nofollow"><span style="color: rgb(0,128,0);">P.id</span></a></span></pre><pre><span style="color: rgb(0,128,0);"> AND</span></pre><pre><span style="color: rgb(0,128,0);"> (P.state = 'OR'</span></pre><pre><span style="color: rgb(0,128,0);"> OR P.state = 'ID'</span></pre><pre><span style="color: rgb(0,128,0);"> OR P.state = 'CA')</span></pre><pre><span style="color: rgb(0,128,0);"> AND A.category = 10;</span></pre></div></div><hr/><p><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 4: What is the average selling price for each auction category?</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates sliding windows and aggregation</span></p></li><ul><li style="list-style-type: circle;"><p><span>Apply Wining-bids</span></p></li><li style="list-style-type: circle;"><p><span> ParDo to key winning-bids by category</span></p></li><li style="list-style-type: circle;"><p><span>apply sliding windows to have a period of time</span></p></li><li style="list-style-type: circle;"><p><span>apply Mean.perKey (key = category)</span></p></li><li style="list-style-type: circle;"><p><span>ParDo that outputs CategoryPrice(categoryId, avgPrice)</span></p></li></ul></ul><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-834624178"><div id="expander-control-834624178" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-834624178" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Istream(AVG(Q.final))</span></pre><pre><span style="color: rgb(0,128,0);">FROM Category C, (</span></pre><pre><span style="color: rgb(0,128,0);"> SELECT Rstream(MAX(B.price) AS final, A.category)</span></pre><pre><span style="color: rgb(0,128,0);"> FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]</span></pre><pre><span style="color: rgb(0,128,0);"> WHERE A.id=B.auction AND B.datetime &lt; A.expires AND A.expires &lt; CURRENT_TIME GROUP BY A.id, A.category) Q</span></pre><pre><span style="color: rgb(0,128,0);">WHERE Q.category = C.id GROUP BY C.id;</span></pre></div></div><hr/><p class="auto-cursor-target"><strong style="letter-spacing: 0.0px;"><span style="letter-spacing: 0.0px;color: rgb(0,0,0);">Query 5: Which auctions have seen the most bids in the last period?</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates sliding windows and combiners (i.e. reducers) to compare the elements in auctions Collection</span></p></li><ul><li style="list-style-type: circle;"><p><span>Input</span><span>: </span><span style="color: rgb(147,196,125);">(sliding) window</span><span> (to have a</span><span> result over</span><span> 1h period </span><span>updated</span><span> every 1 min) collection of </span><span style="color: rgb(109,158,235);">bids</span><span> events</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>replace</span><span> </span><span style="color: rgb(109,158,235);">bid</span><span> elements by their </span><span style="color: rgb(109,158,235);">auction id</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Count.PerElement</span><span> to </span><span>count the occurrences </span><span>of each </span><span style="color: rgb(109,158,235);">auction id</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Combine.globally</span><span> to </span><span>select</span><span> only the </span><span style="color: rgb(109,158,235);">auctions</span><span> with the </span><span>maximum</span><span> </span><span>number</span><span> of </span><span style="color: rgb(109,158,235);">bids</span></p></li><ul><li style="list-style-type: square;"><p><span style="color: rgb(147,196,125);">BinaryCombineFn</span><span> </span><span>to</span><span> compare</span><span> one to one the elements of the collection (</span><span style="color: rgb(109,158,235);">auction id </span><span>occurrences, i.e. number of </span><span style="color: rgb(109,158,235);">bids</span><span>)</span></p></li><li style="list-style-type: square;"><p><span>Return KV(auction id, max occurrences)</span></p></li></ul><li style="list-style-type: circle;"><p><span>output:</span><span> </span><span>AuctionCount(auction id, max occurrences)</span><span> objects</span></p></li></ul></ul><p><br/></p><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-1570038667"><div id="expander-control-1570038667" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-1570038667" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Rstream(auction)</span></pre><pre><span style="color: rgb(0,128,0);">FROM (</span></pre><pre><span style="color: rgb(0,128,0);"> SELECT B1.auction, count(*) AS num</span></pre><pre><span style="color: rgb(0,128,0);"> FROM Bid [RANGE 60 MINUTE SLIDE 1 MINUTE] B1</span></pre><pre><span style="color: rgb(0,128,0);"> GROUP BY B1.auction)</span></pre><pre><span style="color: rgb(0,128,0);">WHERE num &gt;= ALL (</span></pre><pre><span style="color: rgb(0,128,0);"> SELECT count(*)</span></pre><pre><span style="color: rgb(0,128,0);"> FROM Bid [RANGE 60 MINUTE SLIDE 1 MINUTE] B2</span></pre><pre><span style="color: rgb(0,128,0);"> GROUP BY B2.auction);</span></pre></div></div><p><br/></p><hr/><p><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 6:  What is the average selling price per seller for their last 10 closed auctions?</span></strong></p><ul><li style="list-style-type: disc;"><p><span> Illustrates specialized combiner</span></p></li><ul><li style="list-style-type: circle;"><p><span>Apply </span><span style="color: rgb(109,158,235);">winning-bids</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>key</span><span> the </span><span style="color: rgb(109,158,235);">winning-bids</span><span> by </span><span style="color: rgb(109,158,235);">sellerId</span></p></li><li style="list-style-type: circle;"><p><span>apply </span><span style="color: rgb(147,196,125);">GlobalWindow</span><span> + </span><span style="color: rgb(147,196,125);">trigerring</span><span> at </span><span>each</span><span> element (to have a continuous flow of </span><span>updates at each </span><span>new </span><span style="color: rgb(109,158,235);">winning-bid</span><span>)</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Combine.perKey</span><span> to calculate </span><span>average</span><span> of last 10 </span><span style="color: rgb(109,158,235);">winning bids</span><span> for each seller. Need specialized </span><span style="color: rgb(147,196,125);">CombineFn</span><span> because of 10 closed </span><span style="color: rgb(109,158,235);">auctions</span></p></li><ul><li style="list-style-type: square;"><p><span>create </span><span>Arraylist </span><span style="color: rgb(147,196,125);">accumulators</span><span> for chunks of data</span></p></li><li style="list-style-type: square;"><p><span>add all</span><span> elements of the chunks to the </span><span style="color: rgb(147,196,125);">accumulators</span><span>, </span><span>sort</span><span> them by bid </span><span style="color: rgb(147,196,125);">timeStamp</span><span> then </span><span style="color: rgb(109,158,235);">price</span><span> </span><span>keeping last 10</span><span> elements</span></p></li><li style="list-style-type: square;"><p><span>iteratively </span><span>merge</span><span> the </span><span style="color: rgb(147,196,125);">accumulators</span><span> until there is only one: just </span><span>add</span><span> all </span><span style="color: rgb(109,158,235);">bids</span><span> of all </span><span style="color: rgb(147,196,125);">accumulators</span><span> to a final </span><span style="color: rgb(147,196,125);">accumulator</span><span> and </span><span>sort</span><span> by </span><span style="color: rgb(147,196,125);">timeStamp</span><span> then </span><span style="color: rgb(109,158,235);">price</span><span> </span><span>keeping last</span><span> 10 elements</span></p></li><li style="list-style-type: square;"><p><span style="color: rgb(147,196,125);">extractOutput</span><span>: </span><span>sum</span><span> all the </span><span style="color: rgb(109,158,235);">prices</span><span> of the </span><span style="color: rgb(109,158,235);">bids</span><span> and </span><span>divide</span><span> by </span><span style="color: rgb(147,196,125);">accumulator</span><span> size</span></p></li></ul><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> that </span><span>outputs</span><span> SellerPrice(sellerId, avgPrice)</span><span><span class="Apple-tab-span"> </span></span><span><span class="Apple-tab-span"> </span></span></p></li></ul></ul><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-1984635379"><div id="expander-control-1984635379" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-1984635379" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Istream(AVG(Q.final), Q.seller)</span></pre><pre><span style="color: rgb(0,128,0);">FROM (</span></pre><pre><span style="color: rgb(0,128,0);"> SELECT Rstream(MAX(B.price) AS final, A.seller)</span></pre><pre><span style="color: rgb(0,128,0);"> FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]</span></pre><pre><span style="color: rgb(0,128,0);"> WHERE <a class="external-link" href="http://A.id" rel="nofollow"><span style="color: rgb(0,128,0);">A.id</span></a>=B.auction AND B.datetime &lt; A.expires AND A.expires &lt; CURRENT_TIME GROUP BY <a class="external-link" href="http://A.id" rel="nofollow"><span style="color: rgb(0,128,0);">A.id</span></a>, A.seller) [PARTITION BY A.seller ROWS 10] Q</span></pre><pre><span style="color: rgb(0,128,0);">GROUP BY Q.seller;</span></pre></div></div><hr/><p style="text-align: left;"><strong style="color: rgb(0,0,0);letter-spacing: 0.0px;text-align: left;">Query 7: What are the highest bids per period?</strong></p><ul><li style="list-style-type: disc;"><p><span>Could have been implemented with a combiner like query5 but deliberately implemented using Max(prices) as a side input and illustrate fanout. </span></p></li><li style="list-style-type: disc;"><p><span>Fanout is a redistribution using an intermediate implicit combine step to reduce the load in the final step of the Max transform</span></p></li><ul><li style="list-style-type: circle;"><p><span>input</span><span>: </span><span style="color: rgb(147,196,125);">(fixed)</span><span> </span><span style="color: rgb(147,196,125);">windowed</span><span> collection of </span><span style="color: rgb(109,158,235);">bids</span><span> events</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>replace</span><span> </span><span style="color: rgb(109,158,235);">bids</span><span> by their </span><span style="color: rgb(109,158,235);">price</span><span> </span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Max.withFanout</span><span> to get the </span><span>max per window</span><span> and use it as a </span><span style="color: rgb(147,196,125);">side input</span><span> for next step. </span><span style="color: rgb(147,196,125);">Fanout</span><span> is useful if there are many events to be computed in a window using the Max transform.</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> on the </span><span style="color: rgb(109,158,235);">bids</span><span> with </span><span style="color: rgb(147,196,125);">side input</span><span> to </span><span>output</span><span> the </span><span style="color: rgb(109,158,235);">bid</span><span> if </span><span style="color: rgb(109,158,235);">bid.price</span><span> equals maxPrice (that comes from </span><span style="color: rgb(147,196,125);">side input</span><span>)</span></p><p><span><br/></span></p></li></ul></ul><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-1601889431"><div id="expander-control-1601889431" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-1601889431" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Rstream(B.auction, B.price, B.bidder)</span></pre><pre><span style="color: rgb(0,128,0);">FROM Bid [RANGE 1 MINUTE SLIDE 1 MINUTE] B</span></pre><pre><span style="color: rgb(0,128,0);">WHERE B.price = (</span></pre><pre><span style="color: rgb(0,128,0);"> SELECT MAX(B1.price)</span></pre><pre><span style="color: rgb(0,128,0);"> FROM BID [RANGE 1 MINUTE SLIDE 1 MINUTE] B1);</span></pre></div></div><hr/><p><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 8: Who has entered the system and created an auction in the last period?</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates simple join</span></p></li><ul><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Filter</span><span> </span><span><span class="Apple-tab-span"> </span></span><span>+ </span><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>extract</span><span> </span><span style="color: rgb(109,158,235);">persons</span><span> out of events</span></p></li><li style="list-style-type: circle;"><p><span>Apply </span><span style="color: rgb(147,196,125);">fixed windows</span><span> to have a </span><span>period</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>key</span><span> collection by </span><span style="color: rgb(109,158,235);">personId</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Filter</span><span> </span><span><span class="Apple-tab-span"> </span></span><span>+ </span><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>extract</span><span> </span><span style="color: rgb(109,158,235);">auctions</span><span> out of events</span></p></li><li style="list-style-type: circle;"><p><span>Apply </span><span style="color: rgb(147,196,125);">fixed windows</span><span> to have a </span><span>period</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>key</span><span> collection by </span><span style="color: rgb(109,158,235);">sellerId</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">CoGroupByKey</span><span> to </span><span>group</span><span> </span><span style="color: rgb(109,158,235);">persons</span><span> and </span><span style="color: rgb(109,158,235);">auctions</span><span> by </span><span style="color: rgb(109,158,235);">personId</span><span>/</span><span style="color: rgb(109,158,235);">sellerId </span><span>+</span><span style="color: rgb(109,158,235);"> </span><span style="color: rgb(147,196,125);">tag </span><span style="color: rgb(109,158,235);">persons</span><span> and </span><span style="color: rgb(109,158,235);">auctions</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>output</span><span> IdNameReserve(<a class="external-link" href="http://person.id" rel="nofollow">person.id</a>, <a class="external-link" href="http://person.name" rel="nofollow">person.name</a>, auction.reserve) for each </span><span style="color: rgb(109,158,235);">auction</span></p><p><span style="color: rgb(109,158,235);"><br/></span></p></li></ul></ul><div><pre class="auto-cursor-target"><br/></pre><div class="expand-container conf-macro output-block" data-hasbody="true" data-macro-name="expand" id="expander-1050933311"><div id="expander-control-1050933311" class="expand-control" aria-expanded="false"><span class="expand-icon aui-icon aui-icon-small aui-iconfont-chevron-right"> </span><span class="expand-control-text conf-macro-render">SQL Interpretation</span></div><div id="expander-content-1050933311" class="expand-content expand-hidden"><pre><span style="color: rgb(0,128,0);">SELECT Rstream(<a class="external-link" href="http://P.id" rel="nofollow"><span style="color: rgb(0,128,0);">P.id</span></a>, <a class="external-link" href="http://P.name" rel="nofollow"><span style="color: rgb(0,128,0);">P.name</span></a>, A.reserve)</span></pre><pre><span style="color: rgb(0,128,0);">FROM Person [RANGE 12 HOUR] P, Auction [RANGE 12 HOUR] A</span></pre><pre><span style="color: rgb(0,128,0);">WHERE <a class="external-link" href="http://P.id" rel="nofollow"><span style="color: rgb(0,128,0);">P.id</span></a> = A.seller;</span></pre></div></div><span class="auto-cursor-target" style="color: rgb(109,158,235);"><br/></span></div><div><hr/></div><p style="margin-left: 6.0px;"><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 9 Winning-bids (not part of original NexMark): extract the most recent of the highest bids</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates custom window function to reconcile auctions and bids + join them</span></p></li><ul><li style="list-style-type: circle;"><p><span>input</span><span>: collection of events</span></p></li><li style="list-style-type: circle;"><p><span>Apply custom </span><span style="color: rgb(147,196,125);">windowing</span><span> </span><span style="color: rgb(147,196,125);">function</span><span> to </span><span>temporarily</span><span> </span><span>reconcile</span><span> </span><span style="color: rgb(109,158,235);">auctions</span><span> and </span><span style="color: rgb(109,158,235);">bids</span><span> events in the same </span><span style="color: rgb(147,196,125);">custom</span><span> </span><span style="color: rgb(147,196,125);">window</span><span> (AuctionOrBidWindow)</span></p></li><ul><li style="list-style-type: square;"><p><span>assign</span><span> </span><span style="color: rgb(109,158,235);">auctions</span><span> to </span><span style="color: rgb(147,196,125);">window</span><span> [auction.timestamp, auction.expiring]</span></p></li><li style="list-style-type: square;"><p><span>assign</span><span> </span><span style="color: rgb(109,158,235);">bids</span><span> to </span><span style="color: rgb(147,196,125);">window</span><span> [bid.timestamp, bid.timestamp + expectedAuctionDuration (generator configuration parameter)]</span></p></li><li style="list-style-type: square;"><p><span>merge</span><span> all </span><span style="color: rgb(109,158,235);">'bid'</span><span> </span><span style="color: rgb(147,196,125);">windows</span><span> into their corresponding </span><span style="color: rgb(109,158,235);">'auction'</span><span> </span><span style="color: rgb(147,196,125);">window</span><span>, provided the </span><span style="color: rgb(109,158,235);">auction</span><span> has not expired.</span></p></li></ul><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Filter</span><span> + </span><span style="color: rgb(147,196,125);">ParDos</span><span> to </span><span>extract</span><span> </span><span style="color: rgb(109,158,235);">auctions</span><span> out of events and </span><span>key</span><span> them by </span><span style="color: rgb(109,158,235);">auction id</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Filter</span><span> + </span><span style="color: rgb(147,196,125);">ParDos</span><span> to </span><span>extract</span><span> </span><span style="color: rgb(109,158,235);">bids</span><span> out of events and </span><span>key</span><span> them by </span><span style="color: rgb(109,158,235);">auction id</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">CogroupByKey</span><span> (groups values of PCollections&lt;KV&gt; that share the same key) to </span><span>group</span><span> </span><span style="color: rgb(109,158,235);">auctions</span><span> and </span><span style="color: rgb(109,158,235);">bids</span><span> by </span><span style="color: rgb(109,158,235);">auction id</span><span> + </span><span style="color: rgb(147,196,125);">tags </span><span>to distinguish </span><span style="color: rgb(109,158,235);">auctions</span><span> and </span><span style="color: rgb(109,158,235);">bids</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span></p></li><ul><li style="list-style-type: square;"><p><span>determine best</span><span> </span><span style="color: rgb(109,158,235);">bid</span><span> </span><span style="color: rgb(109,158,235);">price</span><span>: verification of </span><span>valid</span><span> </span><span style="color: rgb(109,158,235);">bid</span><span>, </span><span>sort</span><span> prices by </span><span>price ASC</span><span> then </span><span>time DESC</span><span> and </span><span>keep the max price</span></p></li><li style="list-style-type: square;"><p><span>and</span><span> output</span><span> AuctionBid(auction, bestBid) objects</span></p></li></ul></ul></ul><hr/><p style="text-align: left;"><strong style="letter-spacing: 0.0px;text-align: left;"><span style="color: rgb(0,0,0);">Query 10 (not part of original NexMark):Log all events to GCS files</span></strong></p><ul><li style="list-style-type: disc;"><p><span>windows with large side effects on firing</span></p></li><ul><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to key events by their shardId (number of shards is a config item)</span></p></li><li style="list-style-type: circle;"><p><span>Apply </span><span style="color: rgb(147,196,125);">fixed windows</span><span> with composite </span><span style="color: rgb(147,196,125);">triggering</span><span> that fires when each sub-triger (executed in order) fires</span></p></li><ul><li style="list-style-type: square;"><p><span>repeatedly </span></p></li><ul><li style="list-style-type: disc;"><p><span>after at least maxLogEvents in pane </span></p></li><li style="list-style-type: disc;"><p><span>or finally when watermark pass the end of window</span></p></li></ul><li style="list-style-type: square;"><p><span>Repeatedly</span></p></li><ul><li style="list-style-type: disc;"><p><span>after at least maxLogEvents in pane</span></p></li><li style="list-style-type: disc;"><p><span>or processing time pass the first element in pane + lateDelay</span></p></li></ul><li style="list-style-type: square;"><p><span>With </span><span style="color: rgb(147,196,125);">allowedLateness</span><span> of 1 day (so that any late date will stall the pipeline and be noticeable)</span></p></li></ul><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">GroupByKey</span><span> to group events by shardId</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to construct the outputStreams (fileNames contain shardId) and encode each event to that outputStream + form pairs with key = null key and value = outputFile (represents a fileName with various added information)</span></p></li><li style="list-style-type: circle;"><p><span>apply </span><span style="color: rgb(147,196,125);">fixed window</span><span> with default trigger and </span><span style="color: rgb(147,196,125);">lateness</span><span> of 1 day to clear complex triggerring</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">GroupByKey</span><span> all outputFiles together (they have the same</span><span style="color: rgb(109,158,235);"> </span><span>key) to have one file per window</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to write all the lines to files in Google Cloud Storage</span></p></li></ul></ul><hr/><p><strong style="letter-spacing: 0.0px;"><span style="color: rgb(0,0,0);">Query 11 (not part of original NexMark): How many bids did a user make in each session he was active?</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates session windows + triggering on the bids collection</span></p></li><ul><li style="list-style-type: circle;"><p><span>input</span><span>: collection of </span><span style="color: rgb(109,158,235);">bids</span><span> events</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>replace</span><span> </span><span style="color: rgb(109,158,235);">bids </span><span>with their </span><span style="color: rgb(109,158,235);">bidder id</span></p></li><li style="list-style-type: circle;"><p><span>Apply </span><span style="color: rgb(147,196,125);">session windows</span><span> with </span><span style="color: rgb(147,196,125);">gap duration</span><span> = windowDuration (configuration item) and </span><span style="color: rgb(147,196,125);">trigger</span><span> </span><span style="color: rgb(147,196,125);">repeatedly after at least nbEvents in pane</span><span> =&gt; each window (i.e. session) will contain </span><span style="color: rgb(109,158,235);">bid ids</span><span> received since last windowDuration period of inactivity and materialized every nbEvents </span><span style="color: rgb(109,158,235);">bids</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Count.perElement</span><span> to </span><span>count</span><span> </span><span style="color: rgb(109,158,235);">bids</span><span> per </span><span style="color: rgb(109,158,235);">bidder id</span><span> (number of occurrences of </span><span style="color: rgb(109,158,235);">bidder id</span><span>)</span></p></li><li style="list-style-type: circle;"><p><span>output</span><span> idsPerSession(bidder, bidsCount) objects</span></p></li></ul></ul><hr/><p><strong><span style="color: rgb(0,0,0);">Query 12 (not part of original NexMark): How many bids does a user make within a fixed processing time limit?</span></strong></p><ul><li style="list-style-type: disc;"><p><span>Illustrates working in processing time in the Global window to count occurrences of bidder</span></p></li><ul><li style="list-style-type: circle;"><p><span>input</span><span>: collection of </span><span style="color: rgb(109,158,235);">bid</span><span> events</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">ParDo</span><span> to </span><span>replace</span><span> </span><span style="color: rgb(109,158,235);">bids </span><span>by their</span><span style="color: rgb(109,158,235);"> bidder id</span></p></li><li style="list-style-type: circle;"><p><span>Apply </span><span style="color: rgb(147,196,125);">global window</span><span> with </span><span style="color: rgb(147,196,125);">trigger</span><span> </span><span style="color: rgb(147,196,125);">repeatedly after processingTime pass the </span><span style="color: rgb(147,196,125);">first</span><span style="color: rgb(147,196,125);"> element in pane</span><span> + windowDuration (configuration item) =&gt; each pane will contain elements processed within windowDuration time</span></p></li><li style="list-style-type: circle;"><p><span style="color: rgb(147,196,125);">Count.perElement</span><span> to </span><span>count</span><span> </span><span style="color: rgb(109,158,235);">bids</span><span> per </span><span style="color: rgb(109,158,235);">bidder id</span><span> (occurrences of </span><span style="color: rgb(109,158,235);">bidder id</span><span>)</span></p></li><li style="list-style-type: circle;"><p><span>output</span><span> BidsPerWindow(bidder, bidsCount) objects</span></p></li></ul></ul><p><span><br/><br/><br/></span></p>