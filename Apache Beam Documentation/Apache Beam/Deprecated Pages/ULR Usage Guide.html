<div class="confluence-information-macro confluence-information-macro-warning conf-macro output-block" data-hasbody="true" data-macro-name="warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"> </span><div class="confluence-information-macro-body"><p style="text-align: center;"><strong>Deprecated</strong></p><p style="text-align: center;">This page was deprecated by <a class="confluence-userlink user-mention" data-username="danoliveira" href="/confluence/display/~danoliveira" data-linked-resource-id="95650314" data-linked-resource-version="1" data-linked-resource-type="userinfo" data-base-url="https://cwiki.apache.org/confluence">Daniel Oliveira</a> on <time datetime="2020-02-11" class="date-past">11 Feb 2020</time> .</p><p style="text-align: center;">Reason:<br /><em>The Universal Local Runner has been deprecated in Beam.</em></p></div></div><p><br/></p><p><span style="color: rgb(0,0,0);">This page is a guide to using the Universal Local Runner (ULR) for development work, focusing on how to configure and run a pipeline on the ULR for development purposes.</span></p><h1 id="ULRUsageGuide-Prerequisite"><span style="color: rgb(23,43,77);">Prerequisite</span></h1><ul><li><p>Docker must be installed and work without <span style="color: rgb(0,128,0);"><code>sudo</code>.</span> Test this with the command <span style="color: rgb(0,128,0);"><code>docker run hello-world</code></span>.</p></li><li style="list-style-type: disc;"><p><span>Make sure the gradle target  <span style="color: rgb(0,128,0);"><code>:sdks:java:container:docker</code></span> works.</span></p></li></ul><h1 id="ULRUsageGuide-AnatomyofaULRJob"><span style="color: rgb(23,43,77);">Anatomy of a ULR Job</span></h1><p><span style="color: rgb(0,0,0);">Running a job with the ULR involves multiple different components, and a basic knowledge of how these components interact is important for using the ULR for development. These components are:</span></p><ol><li style="list-style-type: decimal;"><p><span>The user code which defines a pipeline and then indirectly calls code to translate that pipeline into protos and send it to the Job Server.</span></p></li><li style="list-style-type: decimal;"><p><span>The Job Server which receives the proto pipeline and executes runner-side transforms while launching the SDK Harness and delegating SDK-side transforms to it.</span></p></li><li style="list-style-type: decimal;"><p><span>The SDK Harness which is launched within a docker container and executes user-defined transforms within a containerized environment.</span></p></li></ol><p><span style="color: rgb(0,0,0);">For development it is useful to understand how each component is executed, what environment it executes in, and how to debug or retrieve logs for it.</span></p><h2 id="ULRUsageGuide-UserCode"><span style="color: rgb(23,43,77);">User Code</span></h2><p><span style="color: rgb(0,0,0);">The user code can be written in any language’s SDK and is built and executed locally on the user’s machine via their build system of choice. The portion of the user code that is in charge of translating the pipeline and sending it across a network boundary for execution is still in active development, so for dev work it is recommended that this code is built with dependencies to published snapshots from the Beam git repo, rather than numbered releases, to ensure that it is as up-to-date as possible. The details of how to publish snapshots of these dependencies and how to use them to build the user code is different depending on the SDK being used.</span></p><p><span style="color: rgb(0,0,0);">Debugging the user code portion is as straightforward as stepping through it with the user’s debugger of choice, and using any logging solution compatible with the Beam SDK being used. However, note that the user code will not execute the pipeline at all, so debugging the execution of the pipeline must be done through the Job Server and SDK Harness.</span></p><h2 id="ULRUsageGuide-JobServer"><span style="color: rgb(23,43,77);">Job Server</span></h2><p><span style="color: rgb(0,0,0);">The ULR Job Server is a Java application that must be running on the user’s local machine in order to receive the translated pipeline. The recommended way to launch this component is via a gradle target in the Beam repository, as this ensures that it uses the current state of the Beam repository.</span></p><p><span style="color: rgb(0,0,0);">Because the Job Server is in charge of executing runner-side transforms, development work with the ULR will often involve debugging via the Job Server. Stepping through this code can be done by running the Job Server with a Java debugger attached. Note, however, that SDK-side transforms are delegated to the SDK Harness and therefore cannot be stepped through.</span></p><h2 id="ULRUsageGuide-SDKHarness"><span style="color: rgb(23,43,77);">SDK Harness</span></h2><p><span style="color: rgb(0,0,0);">The SDK Harness is launched by the Job Server during the execution of a pipeline. It is contained within a docker container, and the specific SDK container used depends on the SDK which was used to write the user code.</span></p><p><span style="color: rgb(0,0,0);">For development purposes, this means that the SDK Harness code cannot be stepped through. Instead, debugging must be done through logs emitted by the SDK Harness. Log messages from the SDK Harness (including log messages within user code) are piped to the Job Server process, which emits them based on the log levels set.</span></p><h1 id="ULRUsageGuide-StartingtheJobServer"><span style="color: rgb(23,43,77);">Starting the Job Server</span></h1><p><span style="color: rgb(0,0,0);">It is necessary to start up the </span><span style="color: rgb(0,0,0);">Job Server</span><span style="color: rgb(0,0,0);"> before executing user code. To run the ULR Job Server via Gradle, simply use this command within your local Beam repository:</span></p><blockquote><p><span style="color: rgb(0,0,0);"><code><span><span style="color: rgb(11,83,148);">beam$</span><span style="color: rgb(0,0,0);"> ./gradlew :runners:reference:job-server:run</span></span></code><br/></span></p></blockquote><p><span style="color: rgb(0,0,0);">By default the Job Server will listen on port 8099. To specify a different port set the “port” property for the task:</span></p><blockquote><p><code><span style="color: rgb(23,43,77);"><span><span style="color: rgb(11,83,148);">beam$</span><span style="color: rgb(0,0,0);"> ./gradlew :runners:reference:job-server:run <span style="color: rgb(0,128,128);">-Pport=12345</span></span></span></span></code></p></blockquote><div class="confluence-information-macro confluence-information-macro-note conf-macro output-block" data-hasbody="true" data-macro-name="note"><p class="title">Bug</p><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"> </span><div class="confluence-information-macro-body"><a class="external-link" href="https://issues.apache.org/jira/browse/BEAM-6141?filter=-1" rel="nofollow">BEAM-6141</a> causes the Job Server to emit a <span style="color: rgb(0,128,0);"><code>grpc.StatusRuntimeException</code></span> after a pipeline finishes executing. This exception can be ignored.</div></div><h1 id="ULRUsageGuide-ExecutingUserCode"><span style="color: rgb(23,43,77);">Executing User Code</span></h1><h2 id="ULRUsageGuide-Java"><span style="color: rgb(23,43,77);">Java</span></h2><p><span style="color: rgb(0,0,0);">To run Java user code that is up-to-date with the Beam repo a snapshot of the jars for the Beam dependencies must be published in a local maven repository and used by the user code. Use the following command to create a snapshot of beam modules in a local maven repository.</span></p><blockquote><p><code><span><span style="color: rgb(11,83,148);">beam$</span><span style="color: rgb(0,0,0);"> </span><span style="color: rgb(34,34,34);">./gradlew -Ppublishing --no-parallel -PdistMgmtSnapshotsUrl=file:///&lt;path_to_local_maven_repository&gt; -p &lt;path_to_beam_module&gt; publish</span></span><br/></code></p></blockquote><p><span style="color: rgb(0,0,0);">The default path to local maven repositories is usually </span><span style="color: rgb(0,128,0);"><code>&lt;usr_home&gt;/.m2/repository</code></span><span style="color: rgb(0,0,0);">, but you can use a custom repository if needed. Leave </span><code><span style="color: rgb(56,118,29);">&lt;path_to_beam_module&gt;</span></code><span style="color: rgb(0,0,0);"> blank if you want to publish the entire project.</span></p><p><span style="color: rgb(0,0,0);">Once your repo is snapshotted you must depend on that snapshot while building your pipeline. See the snippet below for some examples of how to use the snapshotted repository in Gradle. For more info see </span><a class="external-link" href="https://docs.gradle.org/current/userguide/declaring_repositories.html" rel="nofollow"><span style="color: rgb(17,85,204);">the Gradle documentation</span></a><span style="color: rgb(0,0,0);">.</span></p><p><br/></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: groovy; gutter: false; theme: Default" data-theme="Default">repositories {
   maven {
       url &quot;file:///path/to/custom/maven/repo&quot;
   } // Use this when using a non-default local repo.
   mavenLocal() // Use this with the default local repo.
   mavenCentral()
}

dependencies {
   implementation &quot;org.apache.beam-sdks-java-io-kafka:2.9.0-SNAPSHOT&quot;
}</pre>
</div></div><p><br/></p><p><span style="color: rgb(0,0,0);">To run the user code you must already have the Job Server running. Execute the code with  <code><span style="color: rgb(0,128,0);">PortableRunner</span></code> specified as the runner and set a <code><span style="color: rgb(0,128,0);">jobEndpoint</span></code> matching the port the Job Server is connected to. For example, if running user code in a gradle project, the command may look like the following:</span></p><blockquote><p><code><span style="color: rgb(11,83,148);"><span style="color: rgb(11,83,148);">mypipeline</span>$ </span><span style="color: rgb(0,0,0);">./gradlew run --args=&quot;--runner=PortableRunner --jobEndpoint=localhost:8099&quot;</span></code></p></blockquote><h2 id="ULRUsageGuide-Go"><span style="color: rgb(23,43,77);">Go</span></h2><p><span style="color: rgb(0,0,0);">To run a Go pipeline based on the current state of the Beam repo, follow </span><a class="external-link" href="https://github.com/apache/beam/blob/master/sdks/go/README.md#developing-go-beam-sdk-on-github" rel="nofollow"><span style="color: rgb(17,85,204);">the instructions to set up a Go development environment</span></a><span style="color: rgb(0,0,0);">. Once the development environment is set up, you can write pipelines in the Go workspace, as recommended by </span><a class="external-link" href="https://golang.org/doc/code.html" rel="nofollow"><span style="color: rgb(17,85,204);">Go practices</span></a><span style="color: rgb(0,0,0);">.</span></p><p><span style="color: rgb(0,0,0);">To run the pipeline you must already have the ULR Job Server running. Execute the code with the <span style="color: rgb(0,128,0);"><code>universal</code></span> runner specified as the runner and set an <code><span style="color: rgb(0,128,0);">endpoint</span></code> matching the port the Job Server is connected to. For example, if running a pipeline with <code><span style="color: rgb(0,128,0);">go run</span></code>, the command may look like the following:</span></p><blockquote><p><span style="color: rgb(0,0,0);"><code><span style="color: rgb(11,83,148);">$</span> go run $GOPATH/src/github.com/username/project/my_pipeline.go --runner=universal --endpoint=localhost:8099</code></span></p></blockquote><div class="confluence-information-macro confluence-information-macro-note conf-macro output-block" data-hasbody="true" data-macro-name="note"><p class="title">Bug</p><span class="aui-icon aui-icon-small aui-iconfont-warning confluence-information-macro-icon"> </span><div class="confluence-information-macro-body"><p><a class="external-link" href="https://issues.apache.org/jira/browse/BEAM-6140?filter=-1" rel="nofollow">BEAM-6140</a> currently causes the Go pipeline to hang, even after the Job Server has finished running the pipeline. Until this bug is fixed, the job will have to be manually checked in the Job Server, and the pipeline execution will need to be closed manually with Ctrl+C.</p></div></div><h1 id="ULRUsageGuide-Logging"><span style="color: rgb(23,43,77);">Logging</span></h1><p><span style="color: rgb(0,0,0);">Configuring logging for both the Job Server and the SDK Harness is important for development with the ULR. In important detail of how these components handle logs is that the SDK Harness does not emit logs directly. Instead, since it is launched by the Job Server, log output from the SDK Harness is sent to the Job Server which can then choose to emit it.</span></p><p><span style="color: rgb(0,0,0);">This means that the logs from the SDK Harness are filtered twice. For example, imagine that user code executed in the SDK Harness contains a log message of level “Debug”.</span></p><ul><li style="list-style-type: disc;"><p><span>If the SDK Harness log level is set to <code><span style="color: rgb(0,128,0);">INFO</span></code>: The message will be filtered by the SDK Harness and never get sent to the Job Server.</span></p></li><li style="list-style-type: disc;"><p><span>If the SDK Harness log level is set to <code><span style="color: rgb(0,128,0);">DEBUG</span></code> and the Job Server log level is set to </span><span style="color: rgb(0,128,0);"><code>INFO</code></span><span>: The SDK Harness will send the message to the Job Server, which will filter it out and not emit it.</span></p></li><li style="list-style-type: disc;"><p><span>If both are set to a log level of <code><span style="color: rgb(0,128,0);">DEBUG</span></code> or higher: Neither component will filter the message, and it will get emitted by the Job Server.</span></p></li></ul><p><span style="color: rgb(0,0,0);">This means that logs will need to be configured for both components as described below.</span></p><h2 id="ULRUsageGuide-ConfiguringLogsintheJobServer"><span style="color: rgb(23,43,77);">Configuring Logs in the Job Server</span></h2><p><span style="color: rgb(0,0,0);">The ULR Job Server currently uses SLF4J with the <code><span style="color: rgb(0,128,0);">SimpleLogger</span></code> implementation for its logging. The gradle target for the ULR Job Server provides some options for changing the logging level.</span></p><p><span style="color: rgb(0,0,0);">To change the default log level for the Job Server, simply set the <code><span style="color: rgb(0,128,0);">logLevel</span></code> property like so:</span></p><blockquote><p><code><span style="color: rgb(11,83,148);">beam$ </span><span style="color: rgb(0,0,0);">./gradlew :runners:reference:job-server:run </span><span style="color: rgb(0,128,128);">-PlogLevel=debug</span></code></p></blockquote><p><span style="color: rgb(0,0,0);">Vendored code can often be distracting when trying to examine Job Server logs, as they show logs for dependencies that are often not relevant to debugging. For this reason, the gradle target sets the log level for vendored code to <code><span style="color: rgb(0,128,0);">INFO</span></code> by default. To change this default, set the <code><span style="color: rgb(0,128,0);">vendorLogLevel</span></code> property, like so:</span></p><blockquote><p><code><span style="color: rgb(11,83,148);">beam$ </span><span style="color: rgb(0,0,0);">./gradlew :runners:reference:job-server:run -PlogLevel=debug </span><span style="color: rgb(0,128,128);">-PvendorLogLevel=warning</span></code></p></blockquote><p><span style="color: rgb(0,0,0);">The log level for the <code><span style="color: rgb(0,128,0);">SimpleLogger</span></code> is set through JVM flags under the hood. If the basic settings through Gradle don’t offer enough control, refer to the </span><a class="external-link" href="https://www.slf4j.org/api/org/slf4j/impl/SimpleLogger.html" rel="nofollow"><span style="color: rgb(17,85,204);">SimpleLogger reference here</span></a><span style="color: rgb(0,0,0);">.</span></p><h2 id="ULRUsageGuide-ConfiguringLogsintheSDKHarness"><span style="color: rgb(23,43,77);">Configuring Logs in the SDK Harness</span></h2><p><span style="color: rgb(0,0,0);">Because SDK Harnesses are launched by the Job Server, SDK Harness logs are configured indirectly through <code><span style="color: rgb(0,128,0);">PipelineOptions</span></code>. These options are passed from the user code, to the Job Server, and then to the SDK Harness, and they can be configured through code or via the command line, although code is generally most convenient.</span></p><h3 id="ULRUsageGuide-Java.1"><span style="color: rgb(23,43,77);">Java</span></h3><p><span style="color: rgb(0,0,0);">In Java the options are defined in the class <code><span style="color: rgb(0,128,0);">SdkHarnessOptions</span></code>.</span></p><p><span style="color: rgb(0,0,0);">Setting the default log level is done through the option <code><span style="color: rgb(0,128,0);">defaultSdkHarnessLogLevel</span></code>, which can be configured like so:</span></p><p><span style="color: rgb(0,0,0);">Command Line:</span></p><blockquote><p><code><span style="color: rgb(11,83,148);">mypipeline$ </span><span style="color: rgb(0,0,0);">./gradlew run --args=&quot;--runner=PortableRunner --jobEndpoint=localhost:12345  </span><span style="color: rgb(0,128,128);">--defaultSdkHarnessLogLevel=DEBUG</span><span style="color: rgb(0,0,0);">&quot;</span></code></p></blockquote><p><span style="color: rgb(0,0,0);">Programmatically (Java):</span></p><p><br/></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Default" data-theme="Default">SdkHarnessOptions options = PipelineOptionsFactory.fromArgs(args).as(SdkHarnessOptions.class);
options.setDefaultSdkHarnessLogLevel(SdkHarnessOptions.LogLevel.DEBUG);</pre>
</div></div><p><br/></p><p><span style="color: rgb(0,0,0);"><code><span style="color: rgb(0,128,0);">SdkHarnessLogLevelOverrides</span></code> are used to override the default log level for specific packages. This can be used to, for example, set the log level for vendored code or for user-created code separately. This option is represented as a JSON object in the command line and is derived from a <code><span style="color: rgb(0,128,0);">HashMap</span></code> in Java code. For example, to set the log level for vendored code to <code><span style="color: rgb(0,128,0);">INFO</span></code>, and the level for package <code><span style="color: rgb(0,128,0);">mypipeline</span></code> to <code><span style="color: rgb(0,128,0);">TRACE</span></code>, the commands would be as follows:</span></p><p><span style="color: rgb(0,0,0);">Command Line:</span></p><blockquote><p><code><span style="color: rgb(11,83,148);">mypipeline$ </span><span style="color: rgb(0,0,0);">./gradlew run --args=&quot;--runner=PortableRunner --jobEndpoint=localhost:12345 --defaultSdkHarnessLogLevel=DEBUG </span><span style="color: rgb(0,128,128);">--sdkHarnessLogLevelOverrides='\&quot;org.apache.beam.vendor\&quot; : \&quot;INFO\&quot;, \&quot;mypipeline\&quot; : \&quot;TRACE\&quot;}'</span><span style="color: rgb(0,0,0);">&quot;</span></code></p></blockquote><p><span style="color: rgb(0,0,0);">Programmatically (Java):</span></p><p><br/></p><div class="code panel pdl conf-macro output-block" data-hasbody="true" data-macro-name="code" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: java; gutter: false; theme: Default" data-theme="Default">SdkHarnessOptions options = PipelineOptionsFactory.fromArgs(args).as(SdkHarnessOptions.class);
options.setSdkHarnessLogLevelOverrides(
  SdkHarnessOptions.SdkHarnessLogLevelOverrides.from(
      ImmutableMap.of(&quot;org.apache.beam.vendor&quot;, &quot;INFO&quot;, &quot;mypipeline&quot;, &quot;TRACE&quot;)));</pre>
</div></div><h3 class="auto-cursor-target" id="ULRUsageGuide-Go.1">Go</h3><p>N/A</p><h3 id="ULRUsageGuide-RunaPython-SDKPipeline"><strong>Run a Python-SDK Pipeline</strong></h3><p>1. Compile container as a local build:   <span style="color: rgb(0,128,0);">./gradlew :sdks:python:container:docker</span><br/>2. Start ULR job server, for example:  <span style="color: rgb(0,128,0);">./gradlew :runners:reference:job-server:run -PlogLevel=debug -PvendorLogLevel=warning</span><br/><br/>Details see the instructions above for Java.</p><p>3 Set up python environment properly.  More details can be found <a href="https://cwiki.apache.org/confluence/display/BEAM/Python+Tips" rel="nofollow">here</a>. <br/>4. Run pipeline by using following (under folder sdk/python):</p><blockquote><p>python -m apache_beam.examples.wordcount --input=<a href="gs://dataflow-samples/shakespeare/kinglear.txt" rel="nofollow">gs://dataflow-samples/shakespeare/kinglear.txt</a> \</p><p>--output=/tmp/output \</p><p>--runner PortableRunner --job_endpoint=localhost:8099 \</p><p>--experiments beam_fn_api</p></blockquote><p><br/></p>